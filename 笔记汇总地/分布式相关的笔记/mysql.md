# MySql基础

## 列类型

### 数据类型

#### 整型

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1621935809945-1621935809916.png)



# mysql存储引擎

## MYISAM

- 不支持事务

> mysql最常用的存储引擎

### myisam的优点

- 使用三个文件表示每张表
  - 格式文件——存储表结构的定义（mytable.frm）
  - 数据文件——存储表行的内容（mytable.myD）
  - 索引文件——存储表上的索引（mytable.myI）

- 可被压缩节省空间
- 可以被修改为只读表，提高检索效率。



## InnoDB

### 优点

- 支持事务，行级锁外键等
- 在mysql服务器崩溃后可以提供自动恢复。



## memory

- 缺点

不支持事务，数据容易丢失，所有的数据都存在内存当中。

- 优点

查询速度最快。



## 如何选择存储引擎

查询多的选MYISAM

更新多的选择InnoDB



# 事务（重点）

## 事务的原理

- 开启事务

增删改查的操作不会真正修改硬盘里的数据，而是在缓存里保存操作的历史。

- 提交事务

结束事务，把缓存中的历史操作写到硬盘中，清空之前的缓存数据。

- 回滚事务

结束事务，直接清空缓存数据，不操作硬盘。



- 可以通过save point来设置保存点，设置保存点后可以通过rollback+设置到保存点来回到保存点时的数据。

### 事务的四大特性（ACID）

- 原子性

  事务是最小的工作单元，不可再分。

- 一致性

  事务必须保证多语句同时成功或者同时失败。

- 隔离性

  事务A和事务B之间有隔离

- 持久性

  事务的数据最后必须持久化到硬盘中，事务才算成功的结束。





## 事务的隔离级别

 

- 读未提交

对方事务还没有提交，我们当前事务可以读到对方未提交的数据。

读未提交存在脏读现象，表示读到了脏的数据。

- 读已提交

对方提交的事务我方可以读得到。

这种隔离级别解决了脏读现象。

读已提交存在问题是：不可重复读。

- 可重复读

这种隔离级别解决了：不可重复读问题。

存在的问题：读取到的数据是幻象的。

- 序列化读取/串行读取

解决了所有问题。

存在问题：效率低，需要事务排队。



> oracle默认的隔离级别为读已提交。
>
> mysql默认为可重复读。



# 索引

> 索引相当于给表中的数据添加了目录。

- 优点

提高了搜索的效率，缩小了搜索的范围。

- 缺点

经常被修改的表不适合添加索引，索引也相当于表中的对象。表中数据被修改，索引也需要重新排序，需要重新维护。

- 索引底层采用的数据结构： b + Tree

## 索引的实现原理

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1624795579768-1624795579761.png)

索引会对创建索引的字段排序，排序后分区，然后以b+Tree的方式来存储。



# mysql原理

- B+tree

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627376917493-1627376917475.png)



>  mysql（5.6）对每个节点默认大小为16kb
>
>  有数据的节点会占用8b，空数据会占用6b，所以一个节点最多可以存储1170个数据

- hash

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627440179660-1627440179642.png)

> hash查找速度比B+tree还要快，但hash不支持范围查找

- 聚集索引

索引和数据放在一起（查询不需要回表）

- 非聚集索引

索引和数据不在一起（查询需要回表）



> innoDB主键索引查找不需要回表，二级索引需要回表



## 覆盖索引

就是select的数据列只用从索引中就能够取得，不必读取数据行，MYSQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。



- 联合索引

最左前缀法则：联合索引如果想走索引必须先使用第一个索引字段，依次向右。如果跳过了第一个字段，就不会走索引。

联合索引会自动先以第一个索引来建立索引，然后以第二个索引依次类推，按照索引查询时也要以第一个开始来依次向右才会走索引，否则不走。

- 为什么建议InnoDB表必须建主键，并且推荐使用整型的自赠主键？

InnoDB如果不创建主键，系统会自动帮我们维护一个隐藏的rowid来当作主键维护，这样回消耗mysql的性能。如果主键使用uuid，可能会出现一个索引需要放到一个叶子节点已经满了的节点中，这样就会产生叶子节点的分裂，消耗性能，如果采用自增的索引这样产生分裂的情况就会减少。



- 为什么非主键索引结构叶子节点存储的是主键值？



# mysql优化

## 性能分析explain



![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627452207619-1627452207608.png)

- id

如果有子查询，id越大越先执行

- select_type

当前查询的分类

1. simple 简单的select查询，查询中不包含子查询或者UNION
2. primary 查询中若包含任何复杂的子查询，最外层查询就是primary
3. subquery 在select或where中包含子查询
4. derived  在from列表中包含的子查询被标记为derived（衍生）mysql会递归执行这些子查询，把结果放在临时表中。
5. union 若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived
6. union result 从union表获取结果的select



- type（最好到最坏）

> 优化最少到range级别，最好达到ref级别

1. system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计
2. const 表示通过索引一次就找到了，const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快如将主键置于where条件中，mysql就能将该查询转换为一个常量。
3. eq_ref 唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描
4. ref 非唯一性扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
5. range 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引一般就是在你的where语句中出现了between，<,>,in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
6. index index和all的区别为index类型只遍历索引树，这通常比All快，因为索引文件通常比数据文件小（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读取的）
7. all 全表扫描，最差。

- possible_keys

显示可能应用在这张表中的索引，一个或多个。

查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。

- key

实际使用索引

查询中若使用了覆盖索引，则该索引只出现在key列表中

- key_len
- 表示索引中使用的字节数，长度越短越好

- ref

显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被使用于查找索引树上的值。

- raws

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。

- extra

1. <font color="red">Using FIlesort</font> 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序操作称为“文件排序”
2. <font color="red">Using temporary</font> 使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表，常见于排序order by 和分组查询group by
3. <font color="red"> USING index</font> 表示相应的select操作使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引用来读取数据而非执行查找操作。
4. Using where 表示使用了where过滤
5. Using jion buffer 使用了连接缓存
6. impossible where  where子句的值为false，不能用来获取任何元素

# 索引优化

- 索引两表优化

由于左连接的特性，不论如何左表都会全表扫描，left join应该在右表加索引。（右连接反之）

- 三表

索引最好设置在经常查询的字段中。

## 索引失效的情况

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1629166454176-1629166454161.png)

1. 如果有联合索引，查询条件中不能跳过索引前面的列，否则索引会失效。







# 拉钩mysql

- mysql体系架构

![](https://www.helloimg.com/images/2022/04/29/RMpowo.png)

- nysql的运行机制

![](https://www.helloimg.com/images/2022/04/29/RM6WTX.png)

1. 建立连接：

   mysql客户端和服务端的通讯方式是“半双工“，对于每个mysql的连接，时刻都有一个线程状态来标识这个线程现在正在做什么。

   通讯机制：

   - 全双工：可以同时发送数据和接收数据，例如打电话。
   - 单双工：在某一时刻，要么接收数据，要么发送数据，不能同时进行。例如对讲机。
   - 单工：只能发送数据或只能接收数据。例如单行道

2. 查询缓存：如果开启了查询缓存，且在查询缓存过程中查到了完全相同的sql语句，会将查询到的结果直接返回。如果没有开启查询缓存，或者缓存里没有查到此sql，则会由解析器进行语法语义解析，并生成解析树。

   - 缓存的sql语句必须完全相同。



# innoDB

- 存储结构

![](https://www.helloimg.com/images/2022/04/29/RMkK5P.png)

## 内存部分

> 内存部分主要包括BUffer Pool，Change Buffer、Hash Index和Log Buffer四大组件

### Buffer Pool

> 缓冲池，BP以Page页为单位，BP底层采用链表数据结构管理底层Page，在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁盘IO操作，提高效率。

- Page页的管理机制

Page根据数据状态可以分为三种类型：

1. free page：空闲page，未被使用
2. clean page：被使用page，数据没有被修改过
3. dirty page：脏页，数据修改过，页中数据和磁盘的数据产生了不一致

innoDB为了管理上面三种类型提供了三种链表结构：

1. free list：表示空闲缓冲区，管理free page
2. flush list，表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间排序，脏页即在flush链表，也在LRU链表中，但是两种互不影响。LRU链表负责管理page的可用性和释放，而flush链表负责管理脏页的磁盘操作
3. LRU链表：表示正在使用的缓冲区，管理clean page和dirty page。分为呢为new区（存放使用较多的数据）和Old区（存放使用较少的数据）



- LRU算法：

1. 普通LRU：

   末尾淘汰法，新链表从头部插入，释放空间时从尾部释放。

2. 改进型LRU：

   新加入的数据从分割点插入，如果数据很快被访问，数据向new链表头部方向移动，如果没有被访问，就向old尾部移动，等待淘汰。



- change Buffer

> 写缓冲区，简称CB。在进行DML操作时，如果BP没有其相应的Page数据，并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并恢复到BP中。

CB在BP空间中，最多可以占整个BP空间的50%。

当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如果该记录在BufferPool中不存在（没有命中），会直接在ChangeBuffer中进行一次内存操作，不用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进行磁盘读取，然后再从ChangeBuffer中读取信息合并，最终载入BufferPool中。



### LogBuffer(日志缓冲区)

> 用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。
>
> 当LogBuffer空间满了，会自动写入磁盘。

innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1:

0. 每隔1秒写日志文件和刷盘操作（LogBuffer-->OS cache，刷盘操作OS Cache-->磁盘文件），最多丢失一秒数据。
1. 事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作。
2. 事务提交，立刻写日志文件，每隔1秒进行刷盘操作。（推荐）

![](https://www.helloimg.com/images/2022/05/02/R9AHtR.png)



## 磁盘部分

- 表空间

  1. 系统表空间：如果在个人表空间将独立表空间关闭后，Innodb就在系统表空间创建表

     数据字典：表和索引等默认信息在数据字段中存放。（8.0抽出）

     双写缓冲区：Bufferpool数据默认先写到双写缓冲区，然后从此区同步到表。（8.0抽出）

     撤销日志：用于记录每行回滚的日志。（8.0抽出）

  2. 独立表空间：Innodb默认创建的表在独立表空间

  3. 撤销表空间：用于赊销一些操作的表空间

  4. 临时表空间：系统创建临时表的空间

  5. 重做日志：用于重新修复事务操作。

- UndoLog（逻辑日志）

  > 数据库事务开始之前，会将要修改的记录存放到Undo日志里，当事务回滚或者数据库崩溃时，可以利用Undo日志，撤销为提交的事务对数据库产生的影响。

产生：事务开始之前。

销毁：事务提交时，不会立刻删除undo log，事务会将该日志提交到删除列表中，会由清理线程来回收。

- Redo Log

> 事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做日志。

产生：事务操作执行，就会生成Redo Log。

销毁：事务提交时，会将产生的Redo Log写入LogBuffer，并不是随着事务的提交立刻写入磁盘，等事务操作的脏页写入到磁盘之后，RedoLog就可以被重用。



Undo 和Redo执行流程图

![](https://www.helloimg.com/images/2022/05/02/R94V2m.png)

- Binlog

> BInlog为MYSQL Server自己的日志，记录所有数据库表结构变更以及表数据修改的二进制日志，不会记录SELECT和SHOW这类操作。

- 使用场景：
  1. 主从复制：主库中开启Binlog功能，这样主库就能把BInlog传递给从库，从库实现数据恢复，达到主从一致性。
  2. 数据恢复：通过mysqlbinlog工具来恢复数据。

Binlog文件记录有三种模式：

1. ROW：日志会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。

   优点：能清楚记录每一个行修改细节，能完全实现主从数据同步和数据恢复。

   缺点：批量操作会产生大量日志，尤其是alter table会让日志暴涨。

2. STATMENT:每一条被修改数据的SQL都会记录在master的Binlog日志中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的sql再次执行，简称Sql语句复制。

   优点：日志量小，减少磁盘IO，提升存储和恢复速度

   缺点：再某些情况下会导致主从数据不一致，比如用now（）等函数时。

3. MIXED：混合型，根据sql来选择使用ROW或STATMENT模式。



- RedoLog和BinLog的区别（常问）

1. RedoLog是属于InnoDB引擎功能，BInLog是属于MYSQLServer自带功能，并且是以二进制文件来记录。
2. RedoLog属于物理日志，记录该数据页更新状态内容，BinLog是逻辑日志，记录更新内容。
3. RedoLog是循环写入，日志空间大小是固定的，BinLog是追加写入，写完一个写下一个，不会覆盖使用。
4. RedoLog作为服务器异常宕机后事务数据自动恢复使用，BInLog可以作为主从复制和数据恢复使用，BInLog没有自动恢复功能。

## 线程部分

- IO Thread

  在innoDB中使用了大量AIO（异步IO）来进行读写操作，可以极大的提高数据库的性能。

- Purge Thread（清理线程）

  事务提交之后，undo日志将不在需要，因此需要回收线程来回收已经分配的undo页。

- Page Cleaner Thread

  用于调用IOThread中的writeThread同步数据。

- master Thread

  负责调用上面的几种线程。

  - 每1秒：刷新日志到磁盘，合并写缓冲区的数据（根据IO读写压力决定是否做），刷新脏页数据到硬盘（当达到75%时才操作）
  - 每10秒：刷新脏页到到硬盘（无条件），合并写缓冲区到磁盘（无条件），刷新日志缓冲区，删除无用undo页。

# 索引

- 聚簇索引和辅助索引

聚簇索引和非聚簇索引：B+Tree的叶子节点存放主键索引值和行记录就属于聚簇索引；如果行记录和主键分开存放就属于非聚簇索引。

主键索引和辅助索引：B+Tree的叶子节点存放的是主键字段就属于主键索引；如果存放的是非主键值就属于辅助索引（二级索引）

在InnoDB中，主键索引就采用的是聚簇索引结构。

## 索引优化

- 回表

通过索引查询主键值，然后再去聚簇索引查询记录信息。

- 覆盖索引

只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫索引覆盖。常见方法：将被查询的字段，建立到组合索引。

- 索引下沉

之前的索引是由存储引擎查出索引，来由执行引擎过滤，有了索引下成之后可以由存储引擎来进行更详细的过滤。



- MySql在使用like模糊查询时，索引能不能起作用？

只有把%字符写到后面才会使用到索引。

- 如果MYSQL表的某一列含有NULL值，那么包含该列的索引是否有效？

  NULL值比空字符串需要更多的空间存储。虽然MYSQL可以在含有NULL的列上使用索引，不建议列上允许为NULL。

- 慢查询日志

Mysql会在Bin目录下面生成一个slow.log文件。里面会记录执行慢的sql信息。

可以建立一个根据某个字段的值前几位的虚拟列，此列不占用空间，查询时可以直接查询这个字段，来提升查询效率。

慢查询的原因

1. 全表扫描，explain的type为ALL
2. 全索引扫描，explain的type为index
3. 索引过滤性不好：靠索引字段选型，数据量和状态
4. 频繁的回表查询开销，尽量少用select * ，使用覆盖索引。





# 事务和锁

## ACID

- 原子性

> 对数据的修改，要么全都执行，要么全都不执行。

修改->Buffer Pool修改->刷盘。

1. 事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证数据生效？Redo
2. 如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo

每一个写事务，都会修改Buffer Pool，从而产生相应的Redo/Undo日志，在BufferPool中的页被刷到磁盘之前，这些日志信息都会先写到日志文件中，如果BuferPool中的脏页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过Redo日志将其恢复过来，以保证脏页的数据不会丢失。如果脏页刷新成功，此时数据库挂了，就需要通过Undo撤销数据。

- 持久性

> 事务一旦提交，他对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。

![](https://www.helloimg.com/images/2022/05/07/RNF19g.png)

mysql先产生BInlog，之后交给存储引擎来做持久化。

- 隔离性

> 一个事务进行的操作及使用的数据对其他的并发事务是隔离的。

- 一致性

> 事务开始之前和事务结束之后，数据库的完整性限制未被破坏。包括两个方面：约束一致性和数据一致性。



- WAL

先写日志再写磁盘。

![](https://www.helloimg.com/images/2022/05/07/RN1Bbc.png)

- 脏读

一个事务读到了别的事务修改但未提交的数据。

- 不可重复读

一个事务中多次读取同一行记录，后面读取的和前面读取的不一致。

- 幻读

一个事务中多次按相同条件查询，结果不一致。后续查询的结果和前面查询的结果不同，多个了或少了几行记录。

## MVCC（多版本控制）

copy on write。读不加锁，读写不冲突。支持读和读，读和写并行。不支持写和写并行。

支持读以提交，可重复读两种级别。

如何生成多版本?

每次事务修改之前，都会在Undo日志中记录修改之前的数据状态和事务号，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。

- 快照读

  读取的是记录的快照版本（有可能是历史版本），不再加锁。（select）

- 当前读

  读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不再并发修改当前记录。（select....for update或lock in share mode，insert/delete/update）

### 运行机制

![](https://www.helloimg.com/images/2022/05/07/RN1Wuz.png)

隐含id：记录聚簇索引等

事务id：每个事务都有自己的id

回滚指针：指向当前事务回滚，需要回滚到的数据，

1. 用排他锁锁定该行，记录Redo Log
2. 把该行修改前的数据复制到Undo Log。
3. 修改当前行的值，填写事务编号，使回滚指针指向Undo Log中修改当前的行。

## 事务隔离级别和锁

- 隔离级别和锁的关系

读未提交：读操作不加S锁。

读已提交：读操作需要加S锁，但是在查询语句执行完以后立刻释放s锁。

可重复读：读操作需要加S锁，但是事务提交之前并不释放s锁，必须等事务结束才释放。

串行化：在可重复读的基础上，添加一个范围锁，保证一个事务在两次查询时结果完全相同。

- 读锁（S锁）

  共享锁，针对同一份数据，多个读操作可以同时进行而不会相互影响。

  事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加S锁，但是不能追加X锁，需要等记录的S锁全部释放。

- 写锁（X锁）

  排他锁，当前写操作没有完成前，他会阻断其他读锁和写锁。

  事务A对记录追加了x锁，可以对记录进行读和修改操作，其他事务不能对记录进行读和修改操作。



## 行锁

> InnoDB行锁是通过对索引数据页上的记录加锁实现的

3种实现算法：

- RecordLock锁：锁定单个行记录的锁。（记录锁，读已提交，可重复读都支持）
- GapLock锁，间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，可重复读隔离级别支持。）
- Next-Key Lock锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，可重复读隔离级别支持。）

在可重复读隔离级别，InnoDB对于记录加锁行为都优先采用Next-keyLock，但是当SQL操作含有唯一索引时，InnoDB会对Next-KeyLock优化，降级为记录锁，仅锁住索引本身而非范围。



锁原理

- 主键加锁

  仅在主键索引记录上加X锁。

- 唯一键加锁

  先在唯一索引上加x锁，然后在对应唯一索引的主键索引记录上加锁。

- 非唯一键加锁

  对满足其条件的所有主键分别加X锁，然后对满足条件的行记录之间和前后一行加范围锁。

- 无索引加锁

  在全表范围加范围锁。（和表锁上锁原理不同）



## 死锁

- 表级死锁

问题：用户A要操作A表，然后操作B表，先锁A，后锁B。用户B先操作B后A，产生死锁。

解决：属于程序的Bug，需要调整程序逻辑，如果业务涉及多个表，要按一定的顺序锁定表，不管先操作A还是B，都按先锁A，再锁B的顺序上锁。



- 行级死锁

1. 问题：用户在事务中执行了没有索引的条件查询，引发全表扫描，把行级锁上升为全表范围锁，多个这样的事务后，会产生死锁和阻塞，系统会越来越慢，从而导致死锁。

   解决：不要使用太复杂的多表关联查询，对SQL语句进行分析，如果有全表扫描，尽量键索引优化。

2. 问题：先锁行1，再锁行2，另一个用户先锁2后1，产生死锁。

   解决：尽量一次锁所有需要用到的行，或者所有需要用到的行按一定的顺序来锁。



- 共享锁升级为排他锁

问题：事务A先获得一个数据的共享锁，此时事务b要操作此数据，申请了排他锁，事务A的共享锁没有结束，事务B的排他锁进入等待队列。事务A又要申请排他锁，导致此数据死锁。

解决：上述情况在频繁查询再更新操作中常发生，前端页面对按钮做控制，一旦点击立即失效。

或者所有操作都用排他锁。（会大规模降低执行效率）



- 排查：可以查看mysql的死锁日志。



# 集群

## 主从模式

- 主从复制（异步复制）

主从复制整体分为三个步骤：

1. 主库将数据库的变更记录到BinLog日志文件中
2. 从库读取主库中BinLog日志文件信息写入到从库的ReLay Log中继日志中。
3. 从库读取中继文件信息在从库中进行RePlay，更新从库数据信息。

上述三个步骤中设计三个线程：

1. Master的BinlogDump Thread：接收到从库I/O Thread的read请求把BinLog日志发送给Slave的I/o Thread
2. 从库I/OThread将读取到主库的Binlog日志写入从库中的relayLog中。
3. 将测到ReLayLog的变更请求，解析RelayLog中的内容在从库中执行。



**上述的所有操作都是异步请求，俗称异步复制，存在数据延迟现象**



存在的问题：

主库宕机后，数据可能丢失

解决：半同步复制

从库只有一个SQLThread，主库写压力大，复制很可能延迟。

解决：并行复制



- 半同步复制

主库执行完SQL，写好BinLog日志之后，先不提交事务，等从库复制对应的SQL事务提交之后，主库再提交事务。

- 并行复制

5.6：

从库sqlThread按不同的库来用不同的线程同步数据。

问题：

只有一个库会影响性能，

多个库之间的性能会有影响。

**5.7：组提交并行复制**

把多个互不影响，可同时提交的事务分为一组。然后将一组数据同时提给从库来多线程replay。

**InnoDB事务提交分为两个阶段**：

prepare阶段：undo，redo日志刷盘，执行SQL语句。

commit：BInLog写入，undoLog清除，redoLog提交。



**8.0：写集合**（write-Set）

将每个修改的主键id记录hash值，每次修改判断修改的行是否冲突，不冲突的并行复制。可以将颗粒度降到行级。



## 读写分离

主库写，从库读

> 可以在从库追加多个索引优化查询，主库这些索引可以不加，用于提升写效率。

- 主从同步延迟

  在写入数据库后，某个时间段内读操作就去主库，之后读操作访问从库。

- 二次查询

  先去从库读取数据，找不到就去主库读取数据。该操作容易把读压力返回给主库，为了避免恶意攻击，建议将该类操作的api进行分装。

- 根据业务特殊处理

  根据业务特点和重要程度进行区分，重要的，对业务实时性要求高的读主库，其他的读从库。

## 双主模式

> 两台服务器互为主从，任何一台服务器数据变更，都会通过复制应用到另外一方的数据库中。

建议使用双主单写，因为双主双写存在以下问题：

- ID冲突

  A库中写入，当A还为同步到B，B又写入数据，容易让自增主键产生ID冲突。

  解决：可以给每个数据库设置步长，运维维护成本高。（A为1，3，5，7，B为2，4，6，8）

- 更新丢失

  同一条记录，在两个主库中进行更新，容易发生前面数据覆盖后面数据，更新丢失。



- MMM架构

> MMM是一套管理和监控双主复制，支持双主故障切换的第三方软件。MMM使用Perl语言开发，虽然是双主架构，但是业务上同一时间只允许一个节点进行写入操作。

MMM包含writer和reader两种角色，分别对应写节点和读节点：

1. 当writer节点出现故障，程序会自动移除该节点上的VIP
2. 写操作切换到master2，并将master2设置为writer
3. 将所有slave节点指向master2



- MHA主从架构

如果从库发生故障，可以在30秒内将从库快速的切换为主库。

1. 把宕机master的binlog保存下来
2. 根据binlog位置点找到最新的slave
3. 用最新slave的relaylog来修复其他的slave
4. 将保存下来的binlog在最新的slave上恢复
5. 将最新slave提升为master
6. 将其他的slave指向新的master，开启主从复制

## 分库分表

 垂直拆分

把每一条记录分多个地方保存，每个字表的行数相同，把主键和一些列放到一个表，然后把主键和一些列放到另一个表中。

- 优点
  - 可以使得行数据变小，一个数据块就能存放更多的数据，在查询时就会减少I/O次数
  - 可以达到最大化利用cache的目的，具体在垂直拆分的时候把不常变的字段放一起，把经常改变的放一起
  - 便于实现冷热分离的数据表形式
- 缺点
  - 主键出现冗余，需要管理冗余列
  - 会引起表连接Join操作，可以通过在业务服务器上进行jion操作来减少服务器压力，提高系统的复杂度。
  - 依然存在单表数据量过大的问题
  - 事务处理复杂

- 水平拆分

根据表中的某个字段把表中的数据分到不同的表中，每个表只有原来表的一部分数据。



# MySQL性能优化

## 系统参数

- 修改innoDB_Buffer_Pool_Size

  默认为128M，建议修改为内存的3/4

  修改my.cnf

- 可以禁用服务器的swap（虚拟内存）



## 表结构设计优化

- 利用中间表

  可以利用每晚或者空间时间跑比，将需要统计的数据算出来。数据时效性差。





