> 这部分参考自<redis的设计与实现>一书



# 数据结构和对象



## 简单的动态字符串



### SDS和c字符串



> redis的字符串对象是由自创的SDS组成



- SDS的定义

![](https://s2.loli.net/2021/12/30/VhMuZ3KDwSX2mAN.png)

1. 所有SDS的API都以二进制安全的方式来存储buf中的数据，程序不会对其中的数据做任何限制，存入时什么样，读出来就是什么样。
2. 



- SDS和c字符串的不同

1. c字符串获取字符长度虚遍历整个字符串，SDS把长度信息存到len属性中。
2. 避免缓冲区溢出，c语言增大字符串长度，如果没有提前分配内存，容易产生字符串溢出；SDS会现先计算原内存大小，如果不够会自动扩容。

### 减少修改字符串时带来的内存重分配

- 空间预留分配

1. 小于1M，redis会分配和所用空间大小相同的未使用空间给free属性。
2. 大于1M，redis会分配1M的空间给free属性。

- 惰性空间释放

当SDS的api需要缩短SDS字符串时，程序不会立即释放未使用的空间，而是把这部分分给free属性，让下次修改来使用。如果想真正释放这部分空间，SDS提供了专门的API。



## 跳跃表

redis使用跳表来作为有序集合的底层实现之一，如果一个有序集合包含的元素量比较多，又或者有序集合中元素的成员是比较长的字符串时，redis就使用跳表来实现有序序列。



- 每个跳跃表节点的层高都是1至32之间的随机数
- 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值的大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

## 整数集合

- 整数集合的底层实现为数组，这个数组是有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
- 整数集合只支持升级操作，不支持降级操作。



## redis使用的对象

redis系统包含了字符串，列表，哈希表，集合对象，有序集合五种类型的对象。



![](https://s2.loli.net/2022/01/04/aR7YzuwUyrDZVbm.png)



不同对象可以用的数据结构

![](https://s2.loli.net/2022/01/04/3RMPKFbSg162zTL.png)



键所对应的对象

![](https://s2.loli.net/2022/01/04/jdLiZH3YCrc8bXV.png)



### 字符串对象

字符串有int，raw或者embstr

- int

>  如果一个字符串对象保存的时整数值，并且这个整数值可以用long表示，那么字符串对象会把整数值保存在ptr属性里，把字符串的编码设置为int

![](https://s2.loli.net/2022/01/05/PUNW5Cl1SzrKQnc.png)



- raw

> 如果一个字符串对象保存的是一个字符串值，并且这个字符串的长度大于32字节，那么字符串对象就会使用简单动态字符串（SDS）来保存这个字符串值，并把编码设置为raw。

![](https://s2.loli.net/2022/01/05/Ts7JHejv5iOVfQG.png)



- embstr

> 如果保存的是字符串值，且这个字符串值的长度小于等于32字节，字符串对象就用embstr编码来保存这个字符串值。

![](https://s2.loli.net/2022/01/05/1lWBmTFy2rvZb7O.png)



### 列表对象



列表有ziplist或者linkedlist。

- ziplist

> ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存一个元素。（感觉就是java的数组结构）

![](https://s2.loli.net/2022/01/06/pisPSOKQbnBE4Lz.png)

- linkedlist

>  使用双向链表实现，每个节点都保存一个字符串对象，每个字符串对象都保存一个列表元素。

![](https://s2.loli.net/2022/01/06/TdrEyBiZqOXkVpn.png)

满足以下两条件列表使用ziplist，不满足使用linkedlist

- 列表对象保存的所有字符串长度都小于64字节
- 列表对象保存的元素数量小于512个



### 哈希对象

哈希对象的编码可以是ziplist或者hashtable

- ziplist

> ziplist的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，redis会先把保存键的压缩列表节点推入到压缩列表的表尾，再把保存值的压缩列表推到压缩列表的表尾。

1. 保存了同一键值对的两个节点总是紧凑在一起的，保存键的节点在前，保存值的节点在后。
2. 先添加到哈希对象的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

![](https://s2.loli.net/2022/01/06/qVugfcF12yjeMlB.png)



- hashtable

> 字典的键和值都是字符串对象。

![](https://s2.loli.net/2022/01/10/HveU7qFLz4WuTpK.png)



满足以下条件使用ziplist，否则为hashtable

- 所有键值对的字符串长度都小于64字节
- 键值对数量小于512



### 集合对象

> 集合对象是intset或者hashtable

- intset

intset集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里。

![](https://s2.loli.net/2022/01/10/oc4VLlRnf7dbWrq.png)



- hashtable

hashtable使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含一个集合元素，字典的值全部被设置为NULL。

![](https://s2.loli.net/2022/01/10/G1kqtIuQJ6iRKb8.png)



满足以下两个条件使用intset，否则为hashtable

- 集合对象保存的所有元素都是整数
- 集合对象保存的元素数量不超过512个



### 有序集合对象

> 有序集合的实现为ziplist或者为skiplist

- ziplist

压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。

压缩列表内的集合元素按分值从小到大排序，分值小的元素放置在靠近表头的方向，分子大的在靠近表尾的方向。

![](https://s2.loli.net/2022/01/10/oBaR1q2cCL7V4s6.png)



- zset

zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表的object属性保存了元素的成员，而跳跃表节点的score属性保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作。

> zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每一个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值保存了元素的分值。程序可以通过O（1）的复杂度查找给定成员的分值。



- 为什么有序集合需要同时使用跳跃表和字典来实现？

有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现。但无论单独使用字典还是跳跃表，在性能上都会有所降低。

​	如果只使用字典来实现，查找的复杂度为O(1)，而范围操作的时间复杂度为O（NlogN）。空间复杂度为O（N）。

​	如果只使用跳表，查找的复杂度为O（NlogN），范围操作的时间复杂度为O(1)。

![](https://s2.loli.net/2022/01/10/BRTjAuxfseXK8bg.png)



满足以下两个条件使用ziplist，否则为skiplist

- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素成员的长度都小于64字节。



### 内存回收

> redis在自己的对象系统中使用引用计数技术来实现内存回收机制。

每个对象的引用计数信息都由redisObject结构的refcount属性记录：

- 创建一个新对象时，引用计数的值会被初始化为1
- 当对象被新程序使用时，引用值会加1
- 当对象不再被一个程序使用时，引用值减1
- 当对象的引用值变为0时，对象所占用的内存会被释放



redis会共享值为0到9999的字符串对象。

对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。



# 单机数据库的实现



## 数据库

> redis的数据库都保存在服务器的dbnum属性中，在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库。

dbnum属性是由服务器配置的database选项决定的，默认情况下，该选项的值为16，所以redis服务器默认会创建16个数据库。

### 过期键删除策略

> 数据库键的过期时间都保存在过期字典中，
>
> 1检查指定键是否存在于过期字典中，如果存在，就取得过期时间
>
> 2检查当前UNIX时间戳是否大于键的过期时间。

- 定时删除（不推荐用）

设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立刻删除键。

> 对cpu不友好，过期键多时占用cpu高

- 惰性删除（不推荐）

放任键过期不管，每次从键空间获取键时，都检查取得的键是否过期，如果过期就删除键。

> 对cpu最友好，对内存不友好，一些永远不被访问的键会产生内存泄漏。

- 定期删除

每隔一段时间，对数据库进行一次检查，删除过期的键。



## RDB持久化

> RDB可以把redis的数据库状态保存到硬盘中

- SAVE

SAVE命令会阻塞redis服务器进程，直到RDB文件创建完成为止；在服务器进程阻塞期间，无法处理任何命令请求。

- BGSAVE

BGSAVE会生成一个子进程，子进程创建RDB文件，主进程继续处理命令请求。

- 文件载入

RDB文件的载入工作是在服务器启动时自动执行的，redis没有专门载入RDB文件的命令，只要redis启动时检测到RDB文件，就会自动载入。

> AOF文件的更新频率比RDB高，所以只要服务器开启了AOF持久化，就会优先使用AOF，只有在AOF处于关闭状态时，redis才会用RDB来载入数据。

- saveparams

保存save选项设置的保存条件

- dirty计数器

记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改

- lastsave

lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

- serverCron函数

默认每100毫秒执行一次，用于维护正在运行的服务器，可是检测save选项的条件是否满足。

### RDB文件结构

![](https://s2.loli.net/2022/01/12/3frMnXvuHmwGZOt.png)

- redis

> 用来检查此文件是否为RDB文件

- db_version

> 用来记录RDB文件的版本号

- databases

> 保存着数据库数据

- EOF

> 标志RDB正文内容的结束

- check_sum(类似md5)

> 对前面几个内容的校验和，来判断读取的数据是否一致



#### databases的内部结构

![](https://s2.loli.net/2022/01/13/4prRtCsjKQIxiY5.png)

- SELECTDB

> redis读入这个值后，就知道下一个值将是数据库号码

- 𨈖db_number

> 保存着数据号码，提示接下来的数据要存到哪个数据库

- key_value_pairs

> 保存了数据的所有键值对数据，和对应键的过期时间数据。

## AOF持久化

Append Only File

> 通过保存redis服务器执行的写命令来记录服务器的状态。

### AOF持久化的实现

- 命令追加

> 当AOF持久化功能处于打开状态，服务器执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾

- AOF文件的写入与同步

> redis服务器就是一个事件循环，这个循环中的文件负责接受客户端 请求，时间事件负责执行定时任务。
>
> redis在执行写命令时，会把一些内容写到aof_buf缓冲区中，服务器在每次结束一个循环后，都会考虑是否需要把aof_buf缓冲区中的内容写入和保存到AOF文件里面。

- always

每次循环都要写入AOF文件，并且同步文件，效率低，安全。

- everysec

每次循环都会写入AOF文件，有一个子线程每隔一秒会执行一次同步。只会丢失一秒的数据。

- no

每次循环都会写入AOF文件，何时同步由操作系统控制。速度最快，会丢失的数据量未知。

### AOF文件的载入和数据还原

![](https://s2.loli.net/2022/01/14/asTI8wruBYCW36b.png)

### AOF文件重写

- 重写

redis读取现在key对应value的值，用数量尽可能少的写命令记录。

- AOF后台重写

redis创建一个子进程来重写AOF文件，使用子进程可以避免使用锁的情况下，保证数据的安全。

- 重写数据同步

redis在AOF重写期间，主进程收到写命令，会把写命令同时追加到AOF缓冲区和AOF重写缓冲区中。

![](https://s2.loli.net/2022/01/14/AVDUjRGQfMlgYFW.png)



## 事件

### 文件事件

IO多路复用

![](https://s2.loli.net/2022/01/14/cFx8AaSO5YVyifD.png)

- Reactor模式io多路复用

![](https://s2.loli.net/2022/01/14/mqxL3u4sbHIBgAe.png)

如图5所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。



redis基于Reactor模式开发了自己的文件事件处理器：

1. 文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前的任务来为套接字关联不同的事件处理器
2. 当被监听的套接字准备好执行链接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前的事件处理器来处理这些事件。

![](https://s2.loli.net/2022/01/19/LlykIR2MUYJWnbF.png)

> 文件事件和时间事件之间是合作关系，服务器会轮流处理这两个事件，处理过程中也不会进行抢占。

### 客户端

- 服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾
- 客户端的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。
- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1G
- 输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性条件，客户端会立即被关闭；如果客户端在一定时间内超过了服务器的软性限制，客户端也会被关闭。
- 服务器关闭客户端的几种情况：
  1. 网络连接关闭
  2. 发送了不合协议格式的命令请求
  3. 成为了CLIENT KILL的目标
  4. 空转时间超时
  5. 输出缓冲区的大小超过限制

- redis启动的步骤
  1. 初始化服务器状态
  2. 载入服务器配置
  3. 初始化服务器数据结构
  4. 还原数据库状态
  5. 执行事件循环



# 多机数据库的实现

## 复制

### 旧版复制功能的实现(2.8之前)

#### 同步

> 从服务器主动把数据库状态更新到主服务器数据库状态

- 客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器：

1. 从服务器向主服务器发送SYNC命令
2. 主服务器执行BGSAVE命令，向后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 主服务器把RDB文件发给从服务器，从服务器载入RDB文件
4. 主服务器把记录在缓冲区中的写命令发送给从服务器，从服务器读取这些命令

![](https://s2.loli.net/2022/01/19/G89MKu1gtRTBy5r.png)

#### 命令传播

> 主服务器主动把自己的写命令发送给从服务器去执行。

#### 旧版复制的缺陷

主服务器在执行命令传播的过程中，从服务器连接断开，从服务器再连上主服务器，断开过程中的数据从服务器没有。

主服务器执行RDB，从服务器读取RDB来恢复所有数据，这个过程非常浪费资源。



### 新版复制功能的实现（2.8之后）

#### PSYNC命令

2.8之后使用PSYNC命令来代替SYNC来执行复制操作

PSYNC命令分为两种：

- 完全重同步

和SYNC命令相同，主服务器发送RDB文件，从服务器读取来恢复

- 部分重同步

![](https://s2.loli.net/2022/01/19/dHqCOMwfQWepN6Y.png)

从断线期间来读取主服务器接收到的写命令来恢复



#### 部分重同步的实现

主从服务器分别维护了一个复制偏移量，服务器向从服务器传输N个字节的数据，主服务器复制偏移量加N，从服务器读取主服务器N个字节，从服务器复制偏移量加N。

如果两个服务器偏移量不一致，就说明数据不同步。

- 复制积压缓冲区

> 主服务器维护的一个固定长度先进先出的队列，默认大小1M

如果从服务器断线时的数据还在主服务器复制积压缓冲区中，就执行部分重同步。如果不在，执行完全重同步。

![](https://s2.loli.net/2022/01/19/iYJyksG1mCgPEMb.png)



主服务器通过向从服务器传播命令更新从服务器的状态，保持主从服务器的一致；从服务器通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。

###  Sentinel（哨兵）

> 哨兵可以监控任意多个主服务器，以及它们的从服务器，如果主服务器下线了，自动把其中的一个从服务器升级为主服务器。之后如果最初的主服务器上线，会成为新的主服务器的从服务器。

![](https://s2.loli.net/2022/01/19/Wn3D2HPFGv6ZMam.png)

![](https://s2.loli.net/2022/01/19/j9w8iWhmYVp3Usd.png)

> 多个哨兵每次都会随机选举出一个头哨兵，配置以头哨兵的为准，头哨兵来选举出新的主服务器。

![](https://s2.loli.net/2022/01/19/aOEoFqk1YtgVGLK.png)

## 集群

暂时只记录一些

- 集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，哪些槽指派给了其他节点。

- 节点在接收到一个命令请求时，先检查这个命令请求处理的键是否由自己负责，如果不是就返回MOVED错误，MOVED错误携带的信息可以指引客户端转向正确的槽。
- 对redis集群重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于莫个槽的所有键值对从一个节点转移到另一个节点
- 集群中的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求



# 独立功能的实现

## 事务

> Redis通过MULTI，EXEC，WATCH等命令来实现事务，事务提供了一种将多个命令请求打包，然后一次性，按顺序的执行多个命令的机制，并且在事务执行期间，服务器不会中断事务改去执行其他客户端的命令，它会将事务全部处理完毕，才会去执行其他客户端的请求。

- redis事务区别

redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕



#### 事务的ACID性质

- 原子性

数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个也不执行

- 一致性

如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

- 隔离性

即使数据库中有多个事务并发的执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

- 耐久性

当事务执行完毕，执行这个事务所得的结果已经被保存到永久性存储介质里面了。


## 慢查询日志

> 用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。

## 监视器

客户端可以通过执行MONTOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。每次处理请求时，服务器都会遍历监视器链表，将相关信息发送给监视器。

![](https://s2.loli.net/2022/01/20/xbLgj5pSIfmTBNn.png)
