# MySql基础

## 列类型

### 数据类型

#### 整型

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1621935809945-1621935809916.png)



# mysql存储引擎

## MYISAM

- 不支持事务

> mysql最常用的存储引擎

### myisam的优点

- 使用三个文件表示每张表
  - 格式文件——存储表结构的定义（mytable.frm）
  - 数据文件——存储表行的内容（mytable.myD）
  - 索引文件——存储表上的索引（mytable.myI）

- 可被压缩节省空间
- 可以被修改为只读表，提高检索效率。



## InnoDB

### 优点

- 支持事务，行级锁外键等
- 在mysql服务器崩溃后可以提供自动恢复。



## memory

- 缺点

不支持事务，数据容易丢失，所有的数据都存在内存当中。

- 优点

查询速度最快。



## 如何选择存储引擎

查询多的选MYISAM

更新多的选择InnoDB



# 事务（重点）

## 事务的原理

- 开启事务

增删改查的操作不会真正修改硬盘里的数据，而是在缓存里保存操作的历史。

- 提交事务

结束事务，把缓存中的历史操作写到硬盘中，清空之前的缓存数据。

- 回滚事务

结束事务，直接清空缓存数据，不操作硬盘。



- 可以通过save point来设置保存点，设置保存点后可以通过rollback+设置到保存点来回到保存点时的数据。

### 事务的四大特性（ACID）

- 原子性

  事务是最小的工作单元，不可再分。

- 一致性

  事务必须保证多语句同时成功或者同时失败。

- 隔离性

  事务A和事务B之间有隔离

- 持久性

  事务的数据最后必须持久化到硬盘中，事务才算成功的结束。





## 事务的隔离级别

 

- 读未提交

对方事务还没有提交，我们当前事务可以读到对方未提交的数据。

读未提交存在脏读现象，表示读到了脏的数据。

- 读已提交

对方提交的事务我方可以读得到。

这种隔离级别解决了脏读现象。

读已提交存在问题是：不可重复读。

- 可重复读

这种隔离级别解决了：不可重复读问题。

存在的问题：读取到的数据是幻象的。

- 序列化读取/串行读取

解决了所有问题。

存在问题：效率低，需要事务排队。



> oracle默认的隔离级别为读已提交。
>
> mysql默认为可重复读。



# 索引

> 索引相当于给表中的数据添加了目录。

- 优点

提高了搜索的效率，缩小了搜索的范围。

- 缺点

经常被修改的表不适合添加索引，索引也相当于表中的对象。表中数据被修改，索引也需要重新排序，需要重新维护。

- 索引底层采用的数据结构： b + Tree

## 索引的实现原理

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1624795579768-1624795579761.png)

索引会对创建索引的字段排序，排序后分区，然后以b+Tree的方式来存储。



# mysql原理

- B+tree

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627376917493-1627376917475.png)



>  mysql（5.6）对每个节点默认大小为16kb
>
> 有数据的节点会占用8b，空数据会占用6b，所以一个节点最多可以存储1170个数据

- hash

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627440179660-1627440179642.png)

> hash查找速度比B+tree还要快，但hash不支持范围查找

- 聚集索引

索引和数据放在一起（查询不需要回表）

- 非聚集索引

索引和数据不在一起（查询需要回表）



> innoDB主键索引查找不需要回表，二级索引需要回表



## 覆盖索引

就是select的数据列只用从索引中就能够取得，不必读取数据行，MYSQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。



- 联合索引

最左前缀法则：联合索引如果想走索引必须先使用第一个索引字段，依次向右。如果跳过了第一个字段，就不会走索引。

联合索引会自动先以第一个索引来建立索引，然后以第二个索引依次类推，按照索引查询时也要以第一个开始来依次向右才会走索引，否则不走。

- 为什么建议InnoDB表必须建主键，并且推荐使用整型的自赠主键？

InnoDB如果不创建主键，系统会自动帮我们维护一个隐藏的rowid来当作主键维护，这样回消耗mysql的性能。如果主键使用uuid，可能会出现一个索引需要放到一个叶子节点已经满了的节点中，这样就会产生叶子节点的分裂，消耗性能，如果采用自增的索引这样产生分裂的情况就会减少。



- 为什么非主键索引结构叶子节点存储的是主键值？



# mysql优化

## 性能分析explan



![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627452207619-1627452207608.png)

- id

如果有子查询，id越大越先执行

- select_type

当前查询的分类

1. simple 简单的select查询，查询中不包含子查询或者UNION
2. primary 查询中若包含任何复杂的子查询，最外层查询就是primary
3. subquery 在select或where中包含子查询
4. derived  在from列表中包含的子查询被标记为derived（衍生）mysql会递归执行这些子查询，把结果放在临时表中。
5. union 若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived
6. union result 从union表获取结果的select



- table（最好到最坏）

> 优化最少到range级别，最好达到ref级别

1. system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计
2. const 表示通过索引一次就找到了，const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快如将主键置于where条件中，mysql就能将该查询转换为一个常量。
3. eq_ref 唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描
4. ref 非唯一性扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
5. range 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引一般就是在你的where语句中出现了between，<,>,in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
6. index index和all的区别为index类型只遍历索引树，这通常比All快，因为索引文件通常比数据文件小（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读取的）
7. all 全表扫描，最差。

- possible_keys

显示可能应用在这张表中的索引，一个或多个。

查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。

- key

实际使用索引

查询中若使用了覆盖索引，则该索引只出现在key列表中

- key_len
-  表示索引中使用的字节数，长度越短越好

- ref

显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被使用于查找索引树上的值。

- raws

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。

- extra

1. <font color="red">Using FIlesort</font> 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序操作称为“文件排序”
2. <font color="red">Using temporary</font> 使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表，常见于排序order by 和分组查询group by
3. <font color="red"> USING index</font> 表示相应的select操作使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引用来读取数据而非执行查找操作。
4. Using where 表示使用了where过滤
5. Using jion buffer 使用了连接缓存
6. impossible where  where子句的值为false，不能用来获取任何元素

# 索引优化

- 索引两表优化

由于左连接的特性，不论如何左表都会全表扫描，left join应该在右表加索引。（右连接反之）

- 三表

索引最好设置在经常查询的字段中。

## 索引失效的情况

![](https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1629166454176-1629166454161.png)

1. 如果有联合索引，查询条件中不能跳过索引前面的列，否则索引会失效。
2. 
